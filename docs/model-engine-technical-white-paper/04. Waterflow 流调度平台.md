## 4.1 核心概念

“Waterflow”引擎致力于打破传统 BPM 工具与响应式编程工具之间的界限，通过引入一种既支持图形化配置也支持声明式编程的混合设计，为业务流程管理带来前所未有的灵活性和表达力。这种设计允许非技术背景的用户通过直观的图形界面设计复杂的业务流程，同时也支持开发者通过声明式编程构建高度定制化的数据处理逻辑。这不仅大大降低了业务流程设计和管理的门槛，也使得“Waterflow”能够灵活应对各种复杂场景，从而实现更高效的业务流程优化和数据处理。

Waterflow 引擎的核心设计理念基于以下几个关键点：

1. **​双模式操作：​**支持图形化配置与声明式编程双模式操作，降低技术门槛同时保留复杂逻辑处理的控制能力。
2. **​动态任务组合与拆分：​**超越传统 BPM 系统的静态流程定义，引入动态任务组合与拆分机制，提升适应性。
3. **​基于条件的流程控制：​**借鉴响应式编程理念，通过条件过滤器（conditions）精细控制任务流转。
4. **​异步任务执行与背压管理：​**Waterflow 引擎的一个重要特性是，所有任务在任意节点均采用异步执行模式，这不仅提升了处理效率，也增加了系统的响应能力。结合背压（backpressure）机制，Waterflow 能有效管理任务执行的速率，防止数据流速度过快导致的系统压力。通过与 filter 条件相结合，这一机制决定了异步执行后的任务如何进行组合和拆分，确保了数据处理的灵活性和精确性。这种对异步执行的支持和背压管理的引入，使 Waterflow 不仅能够优雅地处理高并发数据流，还能够根据业务逻辑和运行时数据动态调整任务流，为复杂的业务场景和大规模数据处理提供了强大的支持。
5. **​大模型编程的原生支持：​**扩展操作符如 `prompt`、`retrieve`、`model` 等，强化AI驱动业务流程支持。

## 4.2 多源热数据

从流建立的过程上，响应式编排中的 `flux(data).map.reduce` 强调以数据起始，传统响应式编程通过 `subscribe` 建立 `subscription(data)`->`subscriber-subscription`->...->`subscriber` 的数据处理链条。在这个数据链条中，Publisher 概念被抹除，这就决定了该数据处理链条在`subscribe`后是稳定的，数据（data）只能进入第一个 Subscription。

在大模型实际应用场景中，被决策的数据可能在不同场景下从不同的 `subscription` 注入。Waterflow 在概念上强调了“流”的概念：`flows.create().map.reduce.close()`，以此生成了一条 Waterflow。`close` 函数系统建立一条 `publisher`->`subscription`->`subscriber-publisher`->`subscription`...->`subscriber` 链条。Publisher 在数据处理链中始终存在，这样 `publisher.offer(data)` 确保了 Waterflow 可以在任意节点注入符合该节点格式要求的数据。

![image](../resources/model-engine-technical-white-paper/4%20waterflow/multi-source-hot-data.png)

## 4.3 无限水流

在探讨 Waterflow 引擎的“无限水流”特性时，首先定性无限水流为无界流[7]，而非有界流。在 Waterflow 中，流不是由数据源发起，而是预先定义，并且能够接收来自任意数量和类型的数据源的数据。这是通过定义一个灵活的流处理模板实现的，该模板可以接受随时到来的数据项，而不是固定地从特定的数据源启动。

```java
flow = Flows.<DataType>create().map(...).reduce(...);

flow.offer(source1); //从流的第一个节点接收数据发射

flow.offer("some node", source2); //从流的某个节点接收数据发射
```

在上述代码中，`offer` 方法允许从任意节点任何时刻一次或多次将新的数据源灌入已定义的流中，而形成了多节点数据流入的无限水流。这种方式支持了真正意义上的多源数据处理，不受时间窗口或数据到达顺序的约束。无论数据是历史积累的文件内容，还是实时生成的事件流，Waterflow 都可以将它们纳入同一处理逻辑。举例：我们需要构建一个实时数据分析系统，该系统需要同时处理来自不同时间和来源的数据流，例如历史日志文件、实时传感器数据以及即时用户反馈。在“Waterflow”引擎中，我们可以定义一个统一的流处理模板，该模板能够接受任意时间点的任意数据源。这个“无限水流”特性允许来自不同时间和来源的数据项被统一处理，无需担心数据源的同步或合并问题，如下所示：

```java
// Waterflow 引擎伪代码
Flow<Data> analysisFlow = Waterflow.<Data>createFlow()
        .map(data -> enrich(data))
        .reduce((accumulatedData, newData) -> combine(accumulatedData, newData));

// 直接将实现了 Publisher 接口的数据服务作为数据源提供给 analysisFlow
analysisFlow.offer(historicalDataService);

// 同样适用于实时传感器数据和用户反馈
analysisFlow.offer(liveSensorService);
analysisFlow.offer(userFeedbackService);
```

在这个示例中，“无限水流”特性使得来自不同时间段的数据项——无论是昨天的历史日志、今天的实时传感器数据，还是即时的用户反馈——都能在一个预定义的流处理模板中得到统一处理。这种方法减少了对数据同步和流合并逻辑的需求，极大地简化了系统设计，同时提高了数据处理的灵活性和扩展性。

## 4.4 多流交互

![image](../resources/model-engine-technical-white-paper/4%20waterflow/multi-flow-interaction.png)

在 Waterflow 引擎中，无限水流和多源热数据特性共同构成了其核心的多流交互[8]机制。这一机制使得在响应式数据流环境中，任何节点都具备将数据传递给其他流或流中特定节点的能力，如图所示。这种设计增强了整个系统对于动态数据源和异步操作的适应能力。

通过多源热数据和无限水流特性，观察图示特征，每个节点都可以是另外一个节点的输入，任何其他流的节点也可以是这个节点的输入。

1. **​节点与流的交互：​**B1 作为 1 流的一个节点，将数据传入 2 流，2 流处理的结果返回给 B1 节点，作为 B1 的处理结果。
2. **​节点与节点的交互：​**B2 作为 2 流的一个节点，将数据传入 3 流的 A3 节点，A3 节点处理的结果返回给 B2，作为 B2 的处理结果。

## 4.5 节点守候者线程

![image](../resources/model-engine-technical-white-paper/4%20waterflow/waiter.png)

Waterflow 引擎采用“节点守候者[9]”模式：每个数据操作符（operator）都配备了一个专属的“节点守候者”，这些守候者是线程池的管理者，负责调度和优化数据在操作符之间的传递和处理。其工作流程为：

1. ​**线程池管理：​**每个节点守候者负责管理一个线程池，确保数据处理的并发性和效率。
2. ​**数据传递侦测：​**当数据完成一个节点的处理后，下一个节点的守候者会侦测其状态，决定如何接收数据。
3. ​**Push+Pull 数据获取：​**根据节点守候者的状态，数据将以 push 方式传递给处于休眠状态的守候者，或放入背压池等待守候者唤醒。
4. ​**条件满足时的主动处理：​**节点守候者在唤醒后会首先处理 push 过来的数据，然后主动从背压池中 pull 满足条件的数据继续处理。
5. ​**背压池管理：​**节点守候者在处理完 push 的数据后，会根据线程池状态决定如何从背压池中拉取和处理更多数据。
6. ​**状态与资源管理：​**处理完背压池中的所有数据后，节点守候者将重新进入休眠状态，并清理线程池资源，为下一波数据到来做准备。

## 4.6 图形与声明式编程双模式

传统的业务流程管理（BPM）和响应式编程（Reactive Programming[2]）是两种在设计理念、数据流控制和类型系统上存在显著差异的技术范畴。Waterflow 引擎将业务流程管理（BPM）的图形配置和响应式编程的代码编写结合在一个统一的框架中。这种双模式特性允许开发者以图形化的方式管理流程，同时保留了响应式编程的灵活性和强大的数据处理能力。

![image](../resources/model-engine-technical-white-paper/4%20waterflow/double-programming.png)

1. **​建立响应层对基础层的 Reactive Programming 语法包装层：​**

   为了提供一种直观且富有表达力的编程体验，Waterflow 引擎在其基础层之上设立了响应层，这一层采用了 Reactive Programming 的风格并提供了一套语法包装器。Waterflow 支持并不限于以下数据操作符：

   `map(1*a->1*b)`：对数据流中的每个元素应用一个给定的函数，返回结果形成新的数据流。

   `reduce(m*a->1*b)`：将数据流中的元素组合成一个单一的汇总结果，常用于聚合操作。

   `filter(m*a->n*a, m>n)`：对数据流中的元素进行过滤。

   `flat_map(1*a->m*b)`：将数据流中的每个元素转换成新的数据流，然后将这些流合并成一个流。

   `buffer(m*a->1*b, b=a[])`：对数据流中的元素进行批量收集，直到达到指定的大小或时间间隔，然后作为集合发射。

   `window`：针对无界流，对数据流进行时间或数量的分割，便于进行分段处理或分析。

   `keyby`：根据特定的键对数据流进行分组，常用于分组聚合操作。
2. **​建立界面交互层对基础层的 DSL 表达：​**

   为了使业务流程管理（BPM）的图形化配置能够无缝集成至 Waterflow 引擎中，我们引入了基于 JSON 格式的 DSL，以实现流程的声明式描述。该 DSL 层作为界面交互层，允许用户以类 BPM 的格式，利用易于理解和操作的 JSON 结构来描述整个数据流程。为了使 JSON 格式的 DSL 能够覆盖基础层的广泛操作，所有的操作都被统一为高度泛化的 `produce(m*a->n*b)` 操作符。

   通过建立界面交互层对基础层的 DSL 表达，Waterflow 在保持强类型编程优势的同时，为用户提供了一种易于接触和理解的流程定义方法。JSON 格式的 DSL 不仅增强了 BPM 的可访问性，而且为响应式编程引入了新的操作和转换逻辑，这在技术上为流程的定制和扩展提供了更高的灵活性。因此，Waterflow 的界面交互层的引入，不仅拓展了 BPM 的界限，也丰富了响应式编程的实践，体现了在软件工程中对于不同编程范式的深度整合。

## 4.7 Waterflow 对大模型编程的支持

FEL（**F**IT **E**xpression for **L**arge language model）是针对 Waterflow 包装的超集，通过引入一套专门的操作符，即大模型原语，提供了对大模型编程环节的高度约束和引导。这些原语旨在简化与大型机器学习模型交互的复杂性，从而使开发者能够以更高效和结构化的方式构建大模型应用。

1. **prompt（提示表达式）**
   prompt(Prompt) 操作符用于构建聊天消息（Chat Messages），这些消息是通过用户输入的字符串经过加工后，作为模型的输入参数。Prompt 提示器是一个基类，它为生态系统中的多态实现提供了接口，允许定制不同的提示生成方法。
2. **delegate（委托表达式）**
   delegate(Pattern) 操作符实现了对其他模式的委托，它将结果作为输入，执行委托的模式，并返回结果。Pattern 委托基类支持多种实现，如异步处理函数、智能体（Agent）、检索器（Retriever），以及其他多种生态系统实现的 Agents 和 Retrievers。
3. **retrieve（检索表达式）**
   retrieve(Retriever) 是 Delegate 的特殊形式，专门用于检索操作。Retriever 检索器基类支持多种检索器实现，如朴素检索器、增强型检索器等，为数据检索提供多样化的方法。
4. **format（格式器）**
   format(Formatter) 操作符为模型输出提供格式约束，确保输出字符满足特定格式。Formatter 格式器基类允许生态系统通过多态实现不同的格式化输出，如 JSON、XML 等。
5. **fewShot（选择表达式）**
   fewShot(Selector) 操作符向模型提示器提供样例（example），以促进模型提供更优质的答案。Selector 选择器基类允许实现不同的选择策略，如基于长度、相似度的选择器等。
6. **generate（模型表达式）**
   generate(Model) 操作符负责调用具体的大模型并执行。Model 大模型基类分为同步返回和流式返回两类实现，对应于 SyncModel 和 StreamModel。对于 StreamModel，后续节点需要实现 `Runable.invoke(chunk)` 方法以确定对流数据的处理方式。
